<?php

/**
 * @file
 * Main functions and hook implementations of the RDF Taxonomy module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\sparql_entity_storage\Entity\Query\Sparql\SparqlArg;
use Drupal\sparql_entity_storage\Entity\SparqlMapping;
use Drupal\sparql_entity_storage\UriEncoder;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\taxonomy\TermInterface;
use Drupal\taxonomy\VocabularyInterface;

/**
 * Implements hook_ENTITY_TYPE_access().
 */
function rdf_taxonomy_rdf_taxonomy_vocabulary_access(VocabularyInterface $vocabulary, $operation, AccountInterface $account) {
  $locked = ($operation !== 'view') && $vocabulary->getThirdPartySetting('rdf_taxonomy', 'locked', TRUE);
  return AccessResult::forbiddenIf($locked);
}

/**
 * Implements hook_ENTITY_TYPE_access().
 */
function rdf_taxonomy_rdf_taxonomy_term_access(TermInterface $term, $operation, AccountInterface $account) {
  $locked = ($operation !== 'view') && $term->vid->entity->getThirdPartySetting('rdf_taxonomy', 'locked', TRUE);
  return AccessResult::forbiddenIf($locked);
}

/**
 * Implements hook_ENTITY_TYPE_create_access().
 */
function rdf_taxonomy_rdf_taxonomy_term_create_access(AccountInterface $account, array $context, $entity_bundle) {
  $vocabulary = Vocabulary::load($entity_bundle);
  $locked = $vocabulary->getThirdPartySetting('rdf_taxonomy', 'locked', TRUE);
  return AccessResult::forbiddenIf($locked);
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function rdf_taxonomy_form_rdf_taxonomy_term_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\taxonomy\TermInterface $term */
  $term = $form_state->getFormObject()->getEntity();

  $sparql_mapping = SparqlMapping::loadByName('rdf_taxonomy_term', $term->bundle());
  if (!$sparql_mapping->isMapped('weight')) {
    // RDF terms with no weight mapping have 0 weight.
    $form['relations']['weight'] = [
      '#type' => 'value',
      '#value' => 0,
    ];
  }

  // RDF terms have no language. Set the entity default language to prevent a
  // form validation error.
  $form['langcode']['widget'][0]['value']['#default_value'] = $term->language()->getId();

  // RDF Taxonomy doesn't support multiple parents yet.
  $parent = reset($form['relations']['parent']['#default_value']);
  $form['relations']['parent']['#default_value'] = $parent;

  // Visual enhancements.
  $form['relations']['#open'] = TRUE;
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Resets the 'page' variable since the ID of an RDF entity is encoded when
 * retrieved as a raw parameter from the route.
 *
 * The canonical implementation at template_preprocess_taxonomy_term() doesn't
 * know how to deal with the encoded entity IDs found in the URL.
 *
 * @see template_preprocess_taxonomy_term()
 */
function rdf_taxonomy_preprocess_rdf_taxonomy_term(&$variables) {
  /** @var \Drupal\taxonomy\TermInterface $term */
  $term = $variables['term'];
  $variables['page'] = $variables['view_mode'] == 'full' && rdf_taxonomy_term_is_page($term);
}

/**
 * Returns whether the current page is the page of the passed-in term.
 *
 * Adapted from taxonomy_term_is_page().
 *
 * @param \Drupal\taxonomy\Entity\Term $term
 *   A taxonomy term entity.
 *
 * @see taxonomy_term_is_page()
 */
function rdf_taxonomy_term_is_page(Term $term) {
  if (\Drupal::routeMatch()->getRouteName() == 'entity.rdf_taxonomy_term.canonical' && $page_term_id = \Drupal::routeMatch()->getRawParameter('rdf_taxonomy_term')) {
    if (!SparqlArg::isValidResource($page_term_id)) {
      $page_term_id = UriEncoder::decodeUrl($page_term_id);
    }
    return $page_term_id === $term->id();
  }
  return FALSE;
}
